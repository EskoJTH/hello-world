
0123456789

h(k) = mod k m

23 47 17 75 53 33 62 18
[3,7,7,5,3,3,2,8]

a) h(k,i)=(h(k)+i) mod m
23 47 17 75 53 33 62 18
[3,7,8,5,4,6,2,9]
v:[-1,-1,62,23,53,75,33,47,17,18]

b) h(k,i) = (h(k)+i^2) mod m
Ei lopu ikinä.

c) h(k,i) = (h_1(k)+i*h_2(k)) mod m
   where
	h_1(k) = h(k)
	h_2(k) = 7-(k mod 7)

23 47 17 75 53 33 62 18
[3,7,1,5,6,9,2,8]
v:[-1,17,62,23,-1,75,53,47,18,33]"



import Data.Sequence hiding (length, take, drop)
import Prelude
h k = k `mod` 10

taulu :: [Int]
taulu = [23, 47, 17, 75, 53, 33, 62, 18]

lasketaulu lista = map (\ k ->mod k 10) lista

hajo1 lista = Prelude.reverse (foldr (check) [] (Prelude.reverse taulu))

check k ks = recurse k ks 1
  where recurse k ks i
          |elem (h k) ks = recurse (((h k) + i) `mod` 10) ks (i) -- +i // +i*i ... i+1
          |otherwise = h k : ks

check' k ks = recurse k ks 0
  where recurse k ks i
          |elem (h k) ks = recurse (((h k) + i*i) `mod` 10) ks (i+1) -- +i // +i*i ... i+1
          |otherwise = h k : ks

check'' k ks = recurse k ks 0
  where recurse k ks i
          |elem (h k) ks = recurse (((h k) + i*i) `mod` 10) ks (i+1) -- +i // +i*i ... i+1
          |otherwise = h k : ks

laskekaikki = kasaaTaulu (hajo1 taulu) taulu

kasaaTaulu siainnit alkiot = show $ fst $ foldr (\x (y,z) -> (update (head z) x y, drop 1 z)) (fromList (take 10[-1,-1..]), siainnit) (fromList (Prelude.reverse alkiot))

